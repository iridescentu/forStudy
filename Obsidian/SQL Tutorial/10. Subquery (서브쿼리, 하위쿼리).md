- **Subquery**
```sql
# IN, NOT IN
SELECT 
    employee_id, first_name, last_name
FROM
    employees
WHERE
    department_id NOT IN (SELECT 
            department_id
        FROM
            departments
        WHERE
            location_id = 1700)
ORDER BY first_name , last_name;




# 비교연산자
SELECT 
    employee_id, first_name, last_name, salary
FROM
    employees
WHERE
    salary = (SELECT 
            MAX(salary)
        FROM
            employees)
ORDER BY first_name , last_name;



SELECT 
    employee_id, first_name, last_name, salary
FROM
    employees
WHERE
    salary > (SELECT 
            AVG(salary)
        FROM
            employees);




# EXISTS
SELECT 
    department_name
FROM
    departments d
WHERE
    EXISTS( SELECT 
            1
        FROM
            employees e
        WHERE
            salary > 10000
                AND e.department_id = d.department_id)
ORDER BY department_name;




# NOT EXISTS
SELECT 
    department_name
FROM
    departments d
WHERE
    NOT EXISTS( SELECT 
            1
        FROM
            employees e
        WHERE
            salary > 10000
                AND e.department_id = d.department_id)
ORDER BY department_name;




# ALL
SELECT 
    employee_id, first_name, last_name, salary
FROM
    employees
WHERE
    salary >= ALL (SELECT 
            MIN(salary)
        FROM
            employees
        GROUP BY department_id)
ORDER BY first_name , last_name;




# ANY (=SOME) // ANY를 SOME으로 바꿔도 결과는 같음 → ANY == SOME
SELECT 
    employee_id, first_name, last_name, salary
FROM
    employees
WHERE
    salary >= ANY (SELECT 
            MAX(salary)
        FROM
            employees
        GROUP BY department_id);




# FROM절의 서브쿼리
SELECT 
    ROUND(AVG(average_salary), 0)
FROM
    (SELECT 
        AVG(salary) average_salary
    FROM
        employees
    GROUP BY department_id) department_salary;




# SELECT절의 서브쿼리
SELECT 
    employee_id,
    first_name,
    last_name,
    salary,
    (SELECT 
            ROUND(AVG(salary), 0)
        FROM
            employees) average_salary,
    salary - (SELECT 
            ROUND(AVG(salary), 0)
        FROM
            employees) difference
FROM
    employees
ORDER BY first_name , last_name;
```

- **Correlated Subquery (상관서브쿼리)**
	* 일반 서브쿼리는 주 쿼리의 결과에 영향을 받지 않고 독립적으로 실행
	* 상관 서브쿼리는 주 쿼리의 결과에 의존하며, 주 쿼리의 각 행에 대해 실행됩니다. 즉, 상관 서브쿼리의 실행은 주 쿼리의 각 행에 매핑되어 결과를 생성
```sql
/* 서브쿼리에서 WHERE department_id = e.department_id는 현재 행의 department_id와 
동일한 부서에 속한 행들만을 대상으로 평균을 계산. 즉, 서브쿼리는 외부 쿼리의 각 행이 속한 
부서에 대한 평균 봉급을 계산 */
SELECT 
    employee_id, 
    first_name, 
    last_name, 
    salary, 
    department_id
FROM
    employees e
WHERE
    salary > (SELECT 
            AVG(salary)
        FROM
            employees
        WHERE
            department_id = e.department_id)
ORDER BY 
    department_id , 
    first_name , 
    last_name;
// 자기와 부서가 같은 사람들 중 평균을 계산해
// salary가 아닌 SELECT 부분의 값만 바뀜



# 일반 서브쿼리(WHERE절이 없음). 위의 상관서브쿼리와 차이점을 확인
SELECT 
    employee_id, 
    first_name, 
    last_name, 
    salary, 
    department_id
FROM
    employees e
WHERE
    salary > (SELECT 
            AVG(salary)
        FROM
            employees)
ORDER BY 
    department_id , 
    first_name , 
    last_name;
// 부서와 상관없이 전체 인원의 평균과 비교해서 그 평균보다 큰 것들을 표시하겠다는 뜻
// salary 값과 SELECT절 값 둘 다 바뀜



# 상관서브쿼리. 
# 부양가족이 없는 모든 직원
SELECT 
    employee_id, 
    first_name, 
    last_name
FROM
    employees e
WHERE
    NOT EXISTS( SELECT 
            *
        FROM
            dependents d
        WHERE
            d.employee_id = e.employee_id)
ORDER BY first_name , 
         last_name;
```