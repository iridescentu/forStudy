- **Alias**
```sql
# 컬럼의 별칭
SELECT 
    first_name, 
    last_name, 
    salary * 1.1 AS new_salary
FROM
    employees;



# 오류
# FROM > WHERE > SELECT
SELECT 
    first_name, 
    last_name, 
    salary * 1.1 AS new_salary
FROM
    employees
WHERE new_salary > 5000


# FROM > SELECT > ORDER BY
SELECT 
    first_name, 
    last_name, 
    salary * 1.1 AS new_salary
FROM
    employees
ORDER BY new_salary;

# 테이블의 별칭
```

- **INNER JOIN**
```sql
# 2개의 조인
SELECT 
    first_name,
    last_name,
    employees.department_id,
    departments.department_id,
    department_name
FROM
    employees
        INNER JOIN 
    departments ON departments.department_id = employees.department_id
WHERE
    employees.department_id IN (1 , 2, 3);
// JOIN은 반드시 FROM 뒤에 나옴. employees 테이블에 departments 테이블을 join 시키겠다는 뜻. JOIN의 왼쪽 테이블에 오른쪽 테이블을 붙여 주는데, 오른쪽 테이블의 ON 뒤에 오는 조건을 만족해야 함. JOIN 뒤에는 ON 이 붙어야 함. 만약 ON이 빠지면 이상한 데이터가 나오기 때문에 JOIN을 사용할 때 ON을 까먹으면 안 됨.


# 3개의 조인
SELECT
	first_name,
	last_name,
	job_title,
	department_name
FROM
	employees e
INNER JOIN departments d ON d.department_id = e.department_id // departments를 조인하기 때문에 d.department_id와 e.department_id가 같아야 함
INNER JOIN jobs j ON j.job_id = e.job_id // jobs를 조인하기 때문에 j.job_id와 e.job_id가 같아야 함
WHERE
	e.department_id IN (1, 2, 3); // e.department_id가 1, 2, 3인 경우만 표시하라는 뜻
```

- **LEFT JOIN**
```sql
SELECT
	c.country_name,
	c.country_id,
	l.country_id,
	l.street_address,
	l.city
FROM
	countries c
LEFT JOIN locations l ON l.country_id = c.country_id
WHERE
	c.country_id IN ('US', 'UK', 'CN')
	// countries c = 국가 테이블
	// LEFT JOIN locations l ON l.country_id = c.country_id = 위치 테이블
	// l.country_id와 c.country_id가 같은 것을 countries 테이블에 join시킴


SELECT
	country_name
FROM
	countries c
LEFT JOIN locations l ON l.country_id = c.country_id
WHERE
	l.location_id IS NULL
ORDER BY
	country_name;



# 3개의 조인
SELECT
	r.region_name,
	c.country_name,
	l.street_address,
	l.city
FROM
	regions r
LEFT JOIN countries c ON c.region_id = r.region_id
LEFT JOIN locations l ON l.country_id = c.country_id
WHERE
	c.country_id IN ('US', 'UK', 'CN');
```

- **SELF JOIN**
```sql
# 직원의 관리자 표시
SELECT 
    CONCAT(e.first_name, ' ', e.last_name) AS employee, // employee의 이름 + ' ' + 성
    CONCAT(m.first_name, ' ', m.last_name) AS manager // manager의 이름 + ' ' + 성
FROM
    employees e
        INNER JOIN
    employees m ON m.employee_id = e.manager_id // employee이면서 manager인 사람 = 관리자(매니저)
ORDER BY manager;



# 관리자가 없는 최상위 직원 표시
SELECT 
    CONCAT(e.first_name, ' ', e.last_name) AS employee,
    CONCAT(m.first_name, ' ', m.last_name) AS manager
FROM
    employees e
        LEFT JOIN // LEFT JOIN을 사용함으로서 관리자(매니저)가 아닌 사장을 표시함
    employees m ON m.employee_id = e.manager_id
ORDER BY manager;
```

- **UNION** = 교집합의 중복을 하나로 처리해 주는 것
```sql
(SELECT
    baskets.basket_name,
    fruits.fruit_name
FROM
    baskets
LEFT JOIN
    fruits ON baskets.basket_id = fruits.basket_id)
UNION
(SELECT
    baskets.basket_name,
    fruits.fruit_name
FROM
    fruits
LEFT JOIN
    baskets ON baskets.basket_id = fruits.basket_id
WHERE
    baskets.basket_id IS NULL)
```

- **CROSS JOIN** = ON이 없는 상태의 JOIN
```sql
# 판매 조직이 가질 수 있는 가능한 모든 판매 채널 찾기 
SELECT
	sales_org,
	channel
FROM
	sales_organization
CROSS JOIN sales_channel;



# 위와 동일한 쿼리
SELECT
	sales_org,
	channel
FROM
	sales_organization,
	sales_channel;
```